<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android Webview使用小结 · Jeremy'Memo</title><meta name="description" content="Android Webview使用小结 - JeremyHe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><font face="Purisa,URW Chancery L,Ubuntu" color=gray size="7">{</font><font face="Purisa,URW Chancery L,Ubuntu" size=7> AL </font><font color=gray size=7 face="Purisa,URW Chancery L,Ubuntu">}</font></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">INDEX</a></li><li class="nav-list-item"><a href="/about.html" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://github.com/jeremyhe-cn" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android Webview使用小结</h1><div class="post-info">Jan 14, 2015</div><div class="post-content"><h2 id="采用重载URL的方式实现Java与Js交互"><a href="#采用重载URL的方式实现Java与Js交互" class="headerlink" title="采用重载URL的方式实现Java与Js交互"></a>采用重载URL的方式实现Java与Js交互</h2><p>在Android中，常用的Java与Js交互的实现方式是通过函数addJavascriptInterface进行添加在Js中使用的回调代理类。<br>这种方法虽然方便，但是写出来的js代码并不通用。如果IOS也要实现类似的功能或业务，则IOS要另外写一套Js代码。所以不太推荐。  </p>
<p>推荐使用重载URL的方式来实现，因为基本所有的平台都拥有在加载某个URL之前进行一些处理的回调函数。所以这种方式会更加的通用。  </p>
<h2 id="响应Javascript中的alert"><a href="#响应Javascript中的alert" class="headerlink" title="响应Javascript中的alert"></a>响应Javascript中的alert</h2><p>在Android的WebView控件中，默认对JS的alert函数是没有任何反应的<br>要想弹出对应的对话框，则需要我们自己进行实现<br>具体实现代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">webView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</div><div class="line">webView.setWebChromeClient(<span class="keyword">new</span> WebChromeClient()&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onJsAlert</span><span class="params">(WebView view, String url, String message, <span class="keyword">final</span> JsResult result)</span> </span>&#123;</div><div class="line">        AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>);</div><div class="line">        builder.setTitle(<span class="string">"测试alert"</span>);</div><div class="line">        builder.setMessage(message);</div><div class="line">        builder.setPositiveButton(<span class="string">"确定"</span>, <span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</div><div class="line">                result.confirm();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        builder.show();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>通过以上代码就可以实现当JS中执行alert时，在Android上以原生的对话框显示出来，当然这里也可以直接Toast。  </p>
<p>而这段代码中需要注意的地方有两点：  </p>
<ol>
<li><p><strong>返回值必须为<code>true</code>。</strong><br>返回true，则说明已经处理了，不需要交由WebChromeClient来执行。而如果返回的是false，则Webview会继续执行后续的js代码，现象就是，弹出对话框之后，用户还没点确定，后续的js代码已经执行完了.  </p>
</li>
<li><p><strong>最后必须调用result.confirm()。</strong><br>原因在于，如果没有调用此函数，则后续的JS代码将无法继续执行下去。最常见的现象就是，alert对话框只出现一次，第二次再进行alert的时候没有任何反应。其实这里是因为没有调用confirm函数，就相当于在浏览器中alert之后，用户没有点确定。  </p>
</li>
<li><p><strong>result.confirm()应该放到onClick回调中。</strong><br>正如前面说的，调用confirm函数，就相当于用户点击了确定按钮。因此，我们要把confirm函数的调用放到Android原生对话框的“确定”按钮的回调函数中进行调用。<br>之前没理解透，把confirm函数放在了builder.show之后进行调用，结果现象是alert之后，对话框弹出来了，但是后续的js代码没有阻塞，而是继续执行下去了，变得就像是异步了一样，和在chrome中调用js代码的执行逻辑不一致。<br>不过，如果需求就是要直接执行下去，那也可以，只要理解了就行。  </p>
</li>
</ol>
<h2 id="访问证书有问题的SSL网页"><a href="#访问证书有问题的SSL网页" class="headerlink" title="访问证书有问题的SSL网页"></a>访问证书有问题的SSL网页</h2><p>对于有证书问题的网页，比如过期、信息不正确、发行机关不被信任等，Webview默认情况下会拒绝访问。而PC端浏览器的处理则是提供用户进行选择是否要继续，在android也是可以实现的。<br>首先第一种是直接继续，不需要让用户进行选择<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedSslError</span><span class="params">(WebView view, SslErrorHandler handler, SslError error)</span> </span>&#123;</div><div class="line">	<span class="comment">// 默认为调用handler.cancel()方法，因此不要调用super的onReceivedSslError方法</span></div><div class="line">    <span class="comment">// super.onReceivedSslError(view, handler, error);</span></div><div class="line">	handler.proceed();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里要注意的是，千万不要调用super的onReceivedSslError方法，因为此方法中已经调用了handler.cancel()。<br>如果调用了，则会出现第一次无法加载，第二次却能正常访问的现象。  </p>
<h2 id="慎重在shouldoverrideurlloading中返回true"><a href="#慎重在shouldoverrideurlloading中返回true" class="headerlink" title="慎重在shouldoverrideurlloading中返回true"></a>慎重在shouldoverrideurlloading中返回true</h2><p>当设置了WebviewClient时，在shouldoverrideurlloading中如果不需要对url进行拦截做处理，而是简单的继续加载此网址。<br>则建议采用返回false的方式而不是loadUrl的方式进行加载网址。  </p>
<p>为什么这么建议呢？<br>因为如果采用loadUrl的方式进行加载，那么对于加载有跳转的网址时，进行webview.goBack就会特别麻烦。<br>例如加载链接如下：<br>A-&gt;(B-&gt;C-&gt;D)-&gt;E  括号内为跳转<br>如果采用return false的方式，那么在goBack的时候，可以从第二步直接回到A网页。从E回到A只需要执行两次goBack<br>而如果采用的是loadUrl，则没办法直接从第二步回到A网页。因为loadUrl把第二步的每个跳转都认为是一个新的网页加载，因此从E回到A需要执行四次goBack  </p>
<p>只有当不需要加载网址而是拦截做其他处理，如拦截tel:xxx等特殊url做拨号处理的时候，才应该返回true。  </p>
<h2 id="onFormResubmission"><a href="#onFormResubmission" class="headerlink" title="onFormResubmission"></a>onFormResubmission</h2></div></article></div></section><footer><div class="paginator"><a href="/posts/2015/02/03/09_Ubuntu-1204安装Emacs243/" class="prev">PREV</a><a href="/posts/2014/08/05/06_别被函数说明骗了！--走出setInterpolator的深坑/" class="next">NEXT</a></div><div data-thread-key="posts/2015/01/14/08_Android-Webview使用小结/" data-title="Android Webview使用小结" data-url="http://zlv.me/posts/2015/01/14/08_Android-Webview使用小结/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"j-cn"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://zlv.me">JeremyHe</a>, All Rights Reserved.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>